import { SupplyChainWallet } from './interfaces/supply_chain_wallet.ts';
import { LucidEvolution, walletFromSeed } from '@lucid-evolution/lucid';
import { fromText } from '@lucid-evolution/core-utils';
import { Constr, Data } from '@lucid-evolution/plutus';
import { Address, AddressDetails, MintingPolicy, SpendingValidator } from "@lucid-evolution/core-types";
import { applyDoubleCborEncoding, applyParamsToScript, generateSeedPhrase, getAddressDetails, mintingPolicyToId, toPublicKey, toUnit, validatorToAddress } from "@lucid-evolution/utils";
import { PlutusJson } from "./interfaces/plutus_json.ts";

export class SU {
  static getEnvVar(name: string): string {
    const envVar = Deno.env.get(name);
    if (envVar === undefined) {
      throw new Error(`${name} is not defined`);
    }
    return envVar;
  }

  static generateWallet(): SupplyChainWallet {
    const seedPhrase = generateSeedPhrase();

    const wallet = walletFromSeed(seedPhrase, { network: 'Preview' });
    const addressDetails: AddressDetails = getAddressDetails(wallet.address);
    console.log(`Wallet created with address: ${wallet.address}`);
    return {
      ...wallet,
      seedPhrase,
      verificationKey: toPublicKey(wallet.paymentKey),
      verificationKeyHash: addressDetails.paymentCredential!.hash,
    }
  }

  static getFundWallet(): SupplyChainWallet {
    const seedPhrase = SU.getEnvVar("FUND_WALLET_SEED_PHRASE");
    const verificationKey = SU.getEnvVar("FUND_VERIFICATION_KEY");
    const verificationKeyHash = SU.getEnvVar("FUND_VERIFICATION_KEY_HASH");
    const wallet = walletFromSeed(seedPhrase, { network: 'Preview' });
    return {
      ...wallet,
      seedPhrase,
      verificationKey,
      verificationKeyHash,
    }
  }

  // * This is the old implementation of createUserNFTCertificate, where I used the policyId 
  // * and the parameterized validator blueprint generated by aiken cli.
  // static async createUserNFTCertificate(lucid: LucidEvolution): Promise<void> {
  //   const fundAddress = SU.getEnvVar("FUND_ADDRESS");
  //   const signerKey = SU.getEnvVar("FUND_SIGNING_KEY");
  //   const policyId = Deno.readTextFileSync('generated/user_nfts_policy_id').trim();
  //   const tokenName = SU.getEnvVar("USER_NFT_CERTIFICATE_NAME");
  //   const validatorBlueprint = JSON.parse(Deno.readTextFileSync('generated/user_nfts_mint_validator_params.json')) as ConvertedBlueprint;
  //   const mintingPolicy: Script = { type: "PlutusV3", script: applyDoubleCborEncoding(validatorBlueprint.cborHex) };

  //   const redeemer = Data.void();

  //   const unit = policyId + fromText(tokenName);
  //   const date = new Date();
  //   date.setHours(date.getHours() + 1);

  //   lucid.selectWallet.fromPrivateKey(signerKey);

  //   const tx = await lucid.newTx()
  //     .mintAssets({ [unit]: 1n }, redeemer)
  //     .pay.ToAddress(fundAddress, { [unit]: 1n })
  //     .validTo(date.getTime())
  //     .attach.MintingPolicy(mintingPolicy)
  //     .complete();

  //   const signedTx = await tx.sign.withPrivateKey(signerKey).complete();
  //   // const txHash = await signedTx.submit();
  //   // console.log(`User NFT Certificate minted with tx hash: ${txHash}`);
  // }

  // * In this new implementation, the policyId is generated in the code itself
  // * and the validator blueprint is read from the plutus.json file.
  static async createUserNFTCertificates(lucid: LucidEvolution, receiverAddresses: Address[]): Promise<string> {
    const fundWallet = SU.getFundWallet();
    const tokenName = SU.getEnvVar("USER_NFT_CERTIFICATE_TOKEN_NAME");
    const mintCompiledCode = SU.getPlutusMintCompiledCode();
    const script = applyParamsToScript(
      applyDoubleCborEncoding(mintCompiledCode),
      [[fundWallet.verificationKeyHash]]
    );
    const spendingValidator: SpendingValidator = { type: "PlutusV3", script };
    const mintingPolicy: MintingPolicy = { type: "PlutusV3", script };

    const policyId = mintingPolicyToId(mintingPolicy);
    const redeemer = Data.void();

    const datum = SU.generateCIP68Metadata();
    const validatorAddress = validatorToAddress('Preview', spendingValidator);
    const assetName = fromText(tokenName);
    const refUnit = toUnit(policyId, assetName, 100); // label 100 is dedicated for Reference NFT
    const userUnit = toUnit(policyId, assetName, 222); // label 222 is dedicated for NFT
    // const date = new Date();
    // date.setHours(date.getHours() + 1);

    lucid.selectWallet.fromSeed(fundWallet.seedPhrase);

    const userTokenQuantity = receiverAddresses.length;

    let tx = lucid.newTx()
      .addSigner(fundWallet.address)
      .mintAssets(
        {
          [refUnit]: 1n,
          [userUnit]: BigInt(userTokenQuantity),
        },
        redeemer
      )
      .attach.MintingPolicy(mintingPolicy)
      // .validTo(date.getTime())
      .pay.ToContract(
        validatorAddress,
        { kind: "inline", value: datum },
        { [refUnit]: 1n }
      );

    for (const address of receiverAddresses) {
      tx = tx.pay.ToAddress(
        address,
        { [userUnit]: 1n }
      )
    }
    const txToSign = await tx.complete();

    const signedTx = await txToSign.sign.withPrivateKey(fundWallet.paymentKey).complete();
    const txHash = await signedTx.submit();
    console.log(`User NFT Certificate minted with tx hash: ${txHash}`);
    return txHash;
  }

  private static getPlutusMintCompiledCode(): string {
    const validatorBlueprint = JSON.parse(Deno.readTextFileSync('../../on-chain/plutus.json')) as PlutusJson;
    return validatorBlueprint.validators.find((v) => (v.title).endsWith('.mint'))!.compiledCode;
  }

  private static generateCIP68Metadata(): string {
    const name = SU.getEnvVar("USER_NFT_CERTIFICATE_NAME");
    const description = SU.getEnvVar("USER_NFT_CERTIFICATE_DESCRIPTION");
    const image = SU.getEnvVar("USER_NFT_CERTIFICATE_IMAGE");
    const expiration = SU.getEnvVar("USER_NFT_CERTIFICATE_EXPIRATION");

    const metadata = Data.fromJson({ name, description, image });
    const version = BigInt(1);
    const extra: Data[] = [Data.fromJson({ expiration })];
    const cip68 = new Constr(0, [metadata, version, extra]);

    const datum = Data.to(cip68);
    return datum;
  }
}
