import { SupplyChainWallet } from './interfaces/supply_chain_wallet.ts';
import { LucidEvolution, walletFromSeed } from '@lucid-evolution/lucid';
import { fromText } from '@lucid-evolution/core-utils';
import { Constr, Data } from '@lucid-evolution/plutus';
import { Address, Assets, AddressDetails, MintingPolicy, SpendingValidator } from "@lucid-evolution/core-types";
import { applyDoubleCborEncoding, applyParamsToScript, generateSeedPhrase, getAddressDetails, mintingPolicyToId, toPublicKey, toUnit, validatorToAddress } from "@lucid-evolution/utils";
import { PlutusJson } from "./interfaces/plutus_json.ts";
import * as Cardano from "@emurgo/cardano-serialization-lib-nodejs";
import plutusJson from "../../../on-chain/plutus.json" with { type: "json" };
import productsJson from "../products.json" with { type: "json" };
import { Buffer } from "node:buffer";

export class SU {
  static assetName: string = "MER_TOKEN"
  static assetStandardMetadata = {
    name: "MER_TOKEN",
    description: "Token used to identify products in the Mercatour supply chain",
    image: "https://upload.wikimedia.org/wikipedia/commons/1/15/Red_Apple.jpg",
    mediaType: "image/jpeg",
    version: 2,
  };

  static getEnvVar(name: string): string {
    const envVar = Deno.env.get(name);
    if (envVar === undefined) {
      throw new Error(`${name} is not defined`);
    }
    return envVar;
  }

  static generateWallet(): SupplyChainWallet {
    const seedPhrase = generateSeedPhrase();

    const wallet = walletFromSeed(seedPhrase, { network: 'Preview' });
    const addressDetails: AddressDetails = getAddressDetails(wallet.address);
    console.log(`Wallet created with address: ${wallet.address}`);
    return {
      ...wallet,
      seedPhrase,
      verificationKey: toPublicKey(wallet.paymentKey),
      verificationKeyHash: addressDetails.paymentCredential!.hash,
    }
  }

  static getFundWallet(): SupplyChainWallet {
    const seedPhrase = SU.getEnvVar("FUND_WALLET_SEED_PHRASE");
    const verificationKey = SU.getEnvVar("FUND_VERIFICATION_KEY");
    const verificationKeyHash = SU.getEnvVar("FUND_VERIFICATION_KEY_HASH");
    const wallet = walletFromSeed(seedPhrase, { network: 'Preview' });
    return {
      ...wallet,
      seedPhrase,
      verificationKey,
      verificationKeyHash,
    }
  }

  // * This is the old implementation of createUserNFTCertificate, where I used the policyId 
  // * and the parameterized validator blueprint generated by aiken cli.
  // static async createUserNFTCertificate(lucid: LucidEvolution): Promise<void> {
  //   const fundAddress = SU.getEnvVar("FUND_ADDRESS");
  //   const signerKey = SU.getEnvVar("FUND_SIGNING_KEY");
  //   const policyId = Deno.readTextFileSync('generated/user_nfts_policy_id').trim();
  //   const tokenName = SU.getEnvVar("USER_NFT_CERTIFICATE_NAME");
  //   const validatorBlueprint = JSON.parse(Deno.readTextFileSync('generated/user_nfts_mint_validator_params.json')) as ConvertedBlueprint;
  //   const mintingPolicy: Script = { type: "PlutusV3", script: applyDoubleCborEncoding(validatorBlueprint.cborHex) };

  //   const redeemer = Data.void();

  //   const unit = policyId + fromText(tokenName);
  //   const date = new Date();
  //   date.setHours(date.getHours() + 1);

  //   lucid.selectWallet.fromPrivateKey(signerKey);

  //   const tx = await lucid.newTx()
  //     .mintAssets({ [unit]: 1n }, redeemer)
  //     .pay.ToAddress(fundAddress, { [unit]: 1n })
  //     .validTo(date.getTime())
  //     .attach.MintingPolicy(mintingPolicy)
  //     .complete();

  //   const signedTx = await tx.sign.withPrivateKey(signerKey).complete();
  //   // const txHash = await signedTx.submit();
  //   // console.log(`User NFT Certificate minted with tx hash: ${txHash}`);
  // }

  /**
   * This is a method not used anymore in the supply chain concept
   * In this new implementation, the policyId is generated in the code itself
   * and the validator blueprint is read from the plutus.json file.
  */
  static async createUserNFTCertificates(lucid: LucidEvolution, receiverAddresses: Address[]): Promise<string> {
    const fundWallet = SU.getFundWallet();
    const tokenName = SU.getEnvVar("USER_NFT_CERTIFICATE_TOKEN_NAME");
    const mintCompiledCode = SU.getPlutusUserNFTMintCompiledCode();
    const script = applyParamsToScript(
      applyDoubleCborEncoding(mintCompiledCode),
      [[fundWallet.verificationKeyHash]]
    );
    const spendingValidator: SpendingValidator = { type: "PlutusV3", script };
    const mintingPolicy: MintingPolicy = { type: "PlutusV3", script };

    const policyId = mintingPolicyToId(mintingPolicy);
    const redeemer = Data.void();

    const datum = SU.generateCIP68Metadata();
    const validatorAddress = validatorToAddress('Preview', spendingValidator);
    const assetName = fromText(tokenName);
    const refUnit = toUnit(policyId, assetName, 100); // label 100 is dedicated for Reference NFT
    const userUnit = toUnit(policyId, assetName, 222); // label 222 is dedicated for NFT
    // const date = new Date();
    // date.setHours(date.getHours() + 1);

    lucid.selectWallet.fromSeed(fundWallet.seedPhrase);

    const userTokenQuantity = receiverAddresses.length;

    let tx = lucid.newTx()
      .addSigner(fundWallet.address)
      .mintAssets(
        {
          [refUnit]: 1n,
          [userUnit]: BigInt(userTokenQuantity),
        },
        redeemer
      )
      .attach.MintingPolicy(mintingPolicy)
      // .attach.SpendingValidator(spendingValidator)
      // .validTo(date.getTime())
      .pay.ToContract(
        validatorAddress,
        { kind: "inline", value: datum },
        { [refUnit]: 1n }
      );

    for (const address of receiverAddresses) {
      tx = tx.pay.ToAddress(
        address,
        { [userUnit]: 1n }
      )
    }
    const txToSign = await tx.complete();

    const signedTx = await txToSign.sign.withPrivateKey(fundWallet.paymentKey).complete();
    const txHash = await signedTx.submit();
    console.log(`User NFT Certificate minted with tx hash: ${txHash}`);
    return txHash;
  }

  private static getPlutusUserNFTMintCompiledCode(): string {
    const validatorBlueprint = JSON.parse(Deno.readTextFileSync('../../on-chain/plutus.json')) as PlutusJson;
    return validatorBlueprint.validators.find((v) => v.title.endsWith('user_nfts.user_nfts.mint'))!.compiledCode;
  }

  private static generateCIP68Metadata(): string {
    const name = SU.getEnvVar("USER_NFT_CERTIFICATE_NAME");
    const description = SU.getEnvVar("USER_NFT_CERTIFICATE_DESCRIPTION");
    const image = SU.getEnvVar("USER_NFT_CERTIFICATE_IMAGE");
    const expiration = SU.getEnvVar("USER_NFT_CERTIFICATE_EXPIRATION");

    const metadata = Data.fromJson({ name, description, image });
    const version = BigInt(1);
    const extra: Data[] = [Data.fromJson({ expiration })];
    const cip68 = new Constr(0, [metadata, version, extra]);

    const datum = Data.to(cip68);
    return datum;
  }

  static async registerProducts(lucid: LucidEvolution, wallets: SupplyChainWallet[]): Promise<string[]> {
    const pIndex = Math.floor(Math.random() * productsJson.length);
    const productTransactionMetadata = productsJson[pIndex];
    const mintCompiledCode = SU.getRegisteredProductsMintCompiledCode();
    const script = applyDoubleCborEncoding(mintCompiledCode);
    const mintingPolicy: MintingPolicy = { type: "PlutusV3", script };
    const policyId = mintingPolicyToId(mintingPolicy);
    const assetName = fromText(this.assetName);
    const userUnit = toUnit(policyId, assetName, 333); // label 333 is dedicated for FT
    const userTokenQuantity = 12;
    const txHashes: string[] = [];

    const assetMetadata = {
      [policyId]: {
        [assetName]: this.assetStandardMetadata,
      }
    }

    for (const wallet of wallets) {
      lucid.selectWallet.fromSeed(wallet.seedPhrase);
      const message = Buffer.from(crypto.randomUUID()).toString('hex');
      const signature = this.createSignature(wallet, message);
      const publicKeyHex = Cardano.PublicKey.from_bech32(wallet.verificationKey).to_hex();
      const redeemer = Data.to(
        new Constr(0, [
          publicKeyHex,
          fromText(message),
          signature,
        ])
      );

      const tx = lucid.newTx()
        .mintAssets(
          {
            [userUnit]: BigInt(userTokenQuantity),
          },
          redeemer,
        )
        .attachMetadata(4, productTransactionMetadata)
        .attachMetadata(721, assetMetadata)
        .attach.MintingPolicy(mintingPolicy)
        .pay.ToAddress(
          wallet.address,
          { [userUnit]: BigInt(userTokenQuantity) },
        );

      const txToSign = await tx.complete();
      const signedTx = await txToSign.sign.withWallet().complete();
      const txHash = await signedTx.submit();
      console.log(`Product registered with tx hash: ${txHash}`);
      txHashes.push(txHash);
    }

    return txHashes;
  }

  private static createSignature(address: SupplyChainWallet, message: string): string {
    const privateKey = Cardano.PrivateKey.from_bech32(address.paymentKey);
    const messageBytes = new TextEncoder().encode(message);
    const signedMessage = privateKey.sign(messageBytes);
    const signature = Buffer.from(signedMessage.to_bytes()).toString("hex");
    return signature;
  }

  static async sendPayment(lucid: LucidEvolution, address: Address, lovelace: bigint): Promise<string> {
    const fundWallet = SU.getFundWallet();
    lucid.selectWallet.fromSeed(fundWallet.seedPhrase);

    const assets: Assets = { lovelace };
    const tx = await lucid.newTx()
      .pay.ToAddress(address, assets)
      .complete();

    const signedTx = await tx.sign.withPrivateKey(fundWallet.paymentKey).complete();
    const txHash = await signedTx.submit();
    console.log(`Payment submitted with tx hash: ${txHash}`);
    return txHash;
  }

  private static getRegisteredProductsMintCompiledCode(): string {
    return (plutusJson as PlutusJson).validators.find((v) => v.title.endsWith('register_products.register_products.mint'))!.compiledCode;
  }
}
